"""paste Microsoft DrawingML charts from clipboard"""

# Import Python standard libralies
import io
import zipfile
import xml.etree.ElementTree as ET

# Import Veusz modules
import veusz.qtall as qt
import veusz.plugins as plugins

# DrawingML mime (convertable to graph widget)
dmlmime = 'application/x-qt-windows-mime;value="Art::GVML ClipFormat"'

class PasteCharts(plugins.ToolsPlugin):
    """Pasete MS OOXML-formatted charts on clipboard."""

    menu = ('Clipboard', 'Import Microsoft DrawingML chart widgets')
    name = 'Import MS DrawingML chart widgets'
    author = 'Takuro Hosomi'
    description_short = 'Imports MS DrawingML charts from the clipboard'
    description_full = 'Covert DrawingML-formatted charts generated by Microsoft Office\
                         (e.g. Excel or Powerpoint) into veusz graph widgets and datasets'

    def __init__(self):
        """Construct plugin."""
        super().__init__()
        self.mimedata = qt.QApplication.clipboard().mimeData()
        #self.charts = []

        self.fields = [
            plugins.FieldText(
                "text", descr="test",
                default="DEFAULT"),
            plugins.FieldTextEdit(
                "textedit", descr="test",
                default="DEFOFO"),
            plugins.FieldWidget(
                "parent_widget", descr="Parent widget",
                default=""),
            plugins.FieldDataset(
                'ds1', descr="Dataset 1 to change",
                default=''),
            plugins.FieldDatasetMulti(
                'ds1repl',
                descr="Replacement(s) for dataset 1"),
            plugins.FieldDataset(
                'ds2', descr="Dataset 2 to change (optional)",
                default=''),
            plugins.FieldDatasetMulti(
                'ds2repl',
                descr="Replacement(s) for dataset 2",
                ),
            plugins.FieldBool(
                "names", descr="Build new names from datasets",
                default=True),
        ]

    def apply(self, commandinterface, fieldresults):
        """Do the cloning."""
        parent = commandinterface.Root['page1']
        # currentpath = commandinterface.CurrentPath()
        parent = commandinterface.CurrentPath()
        if dmlmime in self.mimedata.formats():
            dmldata = self.mimedata.data(dmlmime).data()
            drawing = DrawingML()
            drawing.load_charts(dmldata)
            if drawing.charts:
                for i, chart in enumerate(drawing.charts):
                    graph = parent.Add('graph', autoadd=False, name='graph1')
                    ax_id_names = {}
                    for ax in chart.axes:
                        pos = ax.axPos
                        ax_id_names[str(ax.id)] = ax.names[pos]
                        axis = graph.Add('axis', name=ax.names[pos])
                        axis.direction.val = ax.directions[pos]
                        axis.otherPosition.val = ax.positions[pos]
                        if ax.label:
                            axis.label.val = ax.label
                        if ax.min:
                            axis.min.val = ax.min
                        if ax.max:
                            axis.max.val = ax.max

                    for j, plot in enumerate(chart.scatterCharts):
                        for k, series in enumerate(plot.serieses):
                            num = int('{}{}{}'.format(i, j, k), 2)
                            xDataName = 'xData{}'.format(num)
                            yDataName = 'yData{}'.format(num)
                            plotName = 'xy{}'.format(num)
                            xy = graph.Add('xy', name=plotName)
                            xy.xData.val = xDataName
                            xy.yData.val = yDataName
                            xy.xAxis.val = ax_id_names[plot.xAxisID]
                            xy.yAxis.val = ax_id_names[plot.yAxisID]
                            # Append set_data commands
                            commandinterface.SetData(xDataName, series.x_vals)
                            commandinterface.SetData(yDataName, series.y_vals)

# add the class to the registry.
plugins.toolspluginregistry.append(PasteCharts)


# Namespace prefixes of DrawingML
Override = r"{http://schemas.openxmlformats.org/package/2006/content-types}Override"
ChartType = r"application/vnd.openxmlformats-officedocument.drawingml.chart+xml"
c = r"{http://schemas.openxmlformats.org/drawingml/2006/chart}"
a = r"{http://schemas.openxmlformats.org/drawingml/2006/main}"

class DrawingML():
    """format for Microsoft Powerpoint images, shapes, and charts"""

    def __init__(self):
        self.charts = []

    def load_charts(self, data: bytearray):
        """Get DrawingML object from bytearray"""
        stream = io.BytesIO(data)
        with zipfile.ZipFile(stream, "r") as z:
            with z.open("[Content_Types].xml") as f:
                tree = ET.fromstring(f.read())
            part_names = []
            for link in tree.findall(Override):
                content_type = link.attrib["ContentType"]
                if content_type == ChartType:
                    part_name = link.attrib["PartName"]
                    part_names.append(part_name)
            for part_name in part_names:
                with io.TextIOWrapper(z.open(part_name.strip("/"), "r"), encoding='utf-8') as f: 
                    xmltext = f.read()
                    tree = ET.fromstring(xmltext)
                    chart = Chart(tree.find(c + "chart"))
                    self.charts.append(chart)


class Chart():
    """chart class"""
    def __init__(self, element):
        self.element = element
        self.title = "graph"
        self.axes = []
        self.scatterCharts = []
        self.barCharts = []
        self.parse()

    def parse(self):
        # Set chart title
        title_wrap = self.element.find(c + "title")
        if title_wrap:
            title_words = title_wrap.findall(".//" + a + "r")
            self.title = "".join([word.find(a + "t").text for word in title_words]) 
        # Set axes
        plotarea = self.element.find(c + "plotArea")
        valaxes = plotarea.findall(c + "valAx")
        cataxes = plotarea.findall(c + "catAx")
        for axis in valaxes:
            self.axes.append(Axis(axis, "num"))
        for axis in cataxes:
            self.axes.append(Axis(axis, "text"))
        # Set charts
        self.scatterCharts = [ScatterChart(element) 
            for element in plotarea.findall(c + "scatterChart")]
        self.barCharts = [BarChart(element) 
            for element in plotarea.findall(c + "barChart")]


class Axis():
    """Axis class"""
    names = {"b": "x1", "l": "y1", "t": "x2", "r": "y2"}
    directions = {"b": "horizontal", "l": "vertical", "t": "horizontal", "r": "vertical"}
    positions = {"b": 0.0, "l": 0.0, "t": 1.0, "r": 1.0}

    def __init__(self, element, axistype):
        self.element = element
        self.type = axistype
        self.id = ""
        self.axPos = "" # "b": bottom, "l": left, "t": top, "r": right
        self.label = ""
        self.min = None
        self.max = None
        self.majorUnit = None
        self.minorUnit = None
        self.majorTickMark = None
        self.minorTickMark = None
        self.parse()

    def parse(self):
        self.id = self.element.find(c + "axId").get("val")
        self.axPos = self.element.find(c + "axPos").get("val")
        label_wrap = self.element.find(c + "title")
        if label_wrap:
            #label_words = label_wrap.find(c + "tx").find(c + "rich").find(a + "p").findall(a + "r")
            label_words = label_wrap.findall(".//" + a + "r")
            self.label = "".join([word.find(a + "t").text for word in label_words]) 
        scaling = self.element.find(c + "scaling")
        if scaling:
            axis_min = scaling.find(c + "min")
            if axis_min is not None:
                self.min = float(axis_min.get("val"))
            axis_max = scaling.find(c + "max")
            if axis_max is not None:
                self.max = float(axis_max.get("val"))
        majorUnit = self.element.find(c + "majorUnit")
        if majorUnit is not None:
            self.majorUnit = float(majorUnit.get("val"))
        minorUnit = self.element.find(c + "minorUnit")
        if minorUnit is not None:
            self.minorUnit = float(minorUnit.get("val"))


class ScatterChart():
    """Scatter chart"""
    def __init__(self, element):
        self.element = element
        self.xAxisID = ""
        self.yAxisID = ""
        self.parse()

    def parse(self):
        self.serieses = [xySeries(element) for element in self.element.findall(c + "ser")]
        axisIDs = self.element.findall(c + "axId")
        if len(axisIDs) == 2:
            self.xAxisID = axisIDs[0].get("val")
            self.yAxisID = axisIDs[1].get("val")


class BarChart():
    """Bar chart"""
    def __init__(self, element):
        self.element = element
        self.parse()

    def parse(self):
        self.serieses = [cvSeries(element) for element in self.element.findall(c + "ser")]


class xySeries():
    """Series made by x and y values"""
    def __init__(self, element):
        self.element = element
        self.xRef = ""
        self.yRef = ""
        self.x_vals = []
        self.y_vals = []
        self.parse()

    def parse(self):
        x_wrap = self.element.find(c + "xVal").find(c + "numRef")
        y_wrap = self.element.find(c + "yVal").find(c + "numRef")
        self.xRef = x_wrap.find(c + "f").text
        self.yRef = y_wrap.find(c + "f").text
        self.x_vals = [float(pt.find(c + "v").text)
            for pt in x_wrap.find(c + "numCache").findall(c + "pt")]
        self.y_vals = [float(pt.find(c + "v").text)
            for pt in y_wrap.find(c + "numCache").findall(c + "pt")]


class cvSeries():
    """Series made by category and y values"""
    def __init__(self, element):
        self.element = element
        self.catRef = ""
        self.valRef = ""
        self.cats = []
        self.vals = []
        self.parse()

    def parse(self):
        cat_wrap = self.element.find(c + "cat").find(c + "numRef")
        val_wrap = self.element.find(c + "val").find(c + "numRef")
        self.catRef = cat_wrap.find(c + "f").text
        self.valRef = val_wrap.find(c + "f").text
        self.cats = [v.find(c + "v").text for v in cat_wrap.find(c + "numCache").find(c + "pt")]
        self.vals = [v.find(c + "v").text for v in val_wrap.find(c + "numCache").find(c + "pt")]
